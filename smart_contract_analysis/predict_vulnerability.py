import os
import pickle
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
from spektral.layers import GCNConv
from spektral.layers.pooling import GlobalAvgPool
from tensorflow.keras.utils import to_categorical

def load_graph(directory):
    with open(directory, 'rb') as f:
        graph = pickle.load(f)
    return graph

def normalized_adjacency(adj):
    degree = np.sum(adj, axis=1) + 1e-6  # Add a small epsilon value
    adj_normalized = adj / degree[:, None]
    return adj_normalized

def graph_to_features(graph, max_nodes, max_features):
    node_labels = {n: i for i, n in enumerate(graph.nodes())}
    x = to_categorical([node_labels[n] for n in graph.nodes()], num_classes=max_features)
    edges = list(graph.edges())
    adj = np.zeros((len(graph.nodes()), len(graph.nodes())))
    for edge in edges:
        adj[node_labels[edge[0]], node_labels[edge[1]]] = 1
    adj_normalized = normalized_adjacency(adj)
    
    # Pad the adjacency matrix with zeros to match the maximum shape
    adj_padded = np.pad(adj_normalized, ((0, max_nodes - adj_normalized.shape[0]), (0, max_nodes - adj_normalized.shape[1])), mode='constant')
    
    # Pad the features with zeros to match the maximum shape
    x_padded = np.pad(x, ((0, max_nodes - x.shape[0]), (0, 0)), mode='constant')
    
    adj_sparse = tf.sparse.from_dense(adj_padded)
    return x_padded, adj_sparse

# Path to the model
model_path = os.path.join('smart_contract_analysis', 'gnn_model.h5')

# Load the model
model = load_model(model_path, custom_objects={'GCNConv': GCNConv, 'GlobalAvgPool': GlobalAvgPool})

# Path to your graph
graph_path = os.path.join('dataset_contracts', 'reentrancy_1.graph')

# Load the graph
graph = load_graph(graph_path)

# Define the maximum number of nodes and features (use the numbers used during training)
max_nodes = 385
max_features = 385

# Convert the graph to features and adjacency matrix
x, adj = graph_to_features(graph, max_nodes, max_features)

# Reshape to the correct form
x = np.expand_dims(x, axis=0)
adj = tf.sparse.expand_dims(adj, axis=0)

# Make the prediction
prediction = model.predict([x, adj])
print(f"Prediction: {prediction}")
threshold = 0.9  # Typically a threshold of 0.5 is used
if prediction[0][0] >= threshold:
    print("The contract is vulnerable to reentrancy attack")
else:
    print("The contract possibly is not vulnerable to reentrancy attack")